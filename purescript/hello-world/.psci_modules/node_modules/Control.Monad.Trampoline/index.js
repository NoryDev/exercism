
/**
 *  | A _trampoline_ monad, which can be used at the bottom of
 *  | a monad transformer stack to avoid stack overflows in large
 *  | monadic computations.
 */
"use strict";
var Prelude = require("../Prelude");
var Control_Monad_Free = require("../Control.Monad.Free");
var Data_Lazy = require("../Data.Lazy");
var Control_Applicative = require("../Control.Applicative");
var Control_Semigroupoid = require("../Control.Semigroupoid");

/**
 *  | Suspend a computation by one step.
 */
var suspend = Control_Monad_Free.suspendF(Data_Lazy.applicativeLazy);

/**
 *  | Run a computation in the `Trampoline` monad.
 */
var runTrampoline = Control_Monad_Free.runFree(Data_Lazy.functorLazy)(Data_Lazy.force);

/**
 *  | Return a value immediately
 */
var done = Control_Applicative.pure(Control_Monad_Free.freeApplicative);

/**
 *  | Use the `Trampoline` monad to represent a `Lazy` value.
 */
var delay$prime = Control_Monad_Free.liftF;

/**
 *  | Use the `Trampoline` monad to represent the delayed evaluation of a value.
 */
var delay = function ($0) {
    return delay$prime(Data_Lazy.defer($0));
};
module.exports = {
    delay: delay, 
    "delay'": delay$prime, 
    done: done, 
    runTrampoline: runTrampoline, 
    suspend: suspend
};
