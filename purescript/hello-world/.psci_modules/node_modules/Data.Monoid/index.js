"use strict";
var Prelude = require("../Prelude");
var Data_Semigroup = require("../Data.Semigroup");
var Data_Unit = require("../Data.Unit");
var Data_Function = require("../Data.Function");
var Data_Ord = require("../Data.Ord");
var Data_Eq = require("../Data.Eq");
var Data_EuclideanRing = require("../Data.EuclideanRing");
var Data_Boolean = require("../Data.Boolean");

/**
 *  | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a
 *  | left and right unit for the associative operation `<>`:
 *  |
 *  | ```text
 *  | forall x. mempty <> x = x <> mempty = x
 *  | ```
 *  |
 *  | `Monoid`s are commonly used as the result of fold operations, where
 *  | `<>` is used to combine individual results, and `mempty` gives the result
 *  | of folding an empty collection of elements.
 */
var Monoid = function (__superclass_Data$dotSemigroup$dotSemigroup_0, mempty) {
    this["__superclass_Data.Semigroup.Semigroup_0"] = __superclass_Data$dotSemigroup$dotSemigroup_0;
    this.mempty = mempty;
};
var monoidUnit = new Monoid(function () {
    return Data_Semigroup.semigroupUnit;
}, Data_Unit.unit);
var monoidString = new Monoid(function () {
    return Data_Semigroup.semigroupString;
}, "");
var monoidArray = new Monoid(function () {
    return Data_Semigroup.semigroupArray;
}, [  ]);

/**
 *  | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a
 *  | left and right unit for the associative operation `<>`:
 *  |
 *  | ```text
 *  | forall x. mempty <> x = x <> mempty = x
 *  | ```
 *  |
 *  | `Monoid`s are commonly used as the result of fold operations, where
 *  | `<>` is used to combine individual results, and `mempty` gives the result
 *  | of folding an empty collection of elements.
 */
var mempty = function (dict) {
    return dict.mempty;
};
var monoidFn = function (dictMonoid) {
    return new Monoid(function () {
        return Data_Semigroup.semigroupFn(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
    }, Data_Function["const"](mempty(dictMonoid)));
};

/**
 *  | Append a value to itself a certain number of times. For the
 *  | `Multiplicative` type, and for a non-negative power, this is the same as
 *  | normal number exponentiation.
 *  |
 *  | If the second argument is negative this function will return `mempty`
 *  | (*unlike* normal number exponentiation). The `Monoid` constraint alone
 *  | is not enough to write a `power` function with the property that `power x
 *  | n` cancels with `power x (-n)`, i.e. `power x n <> power x (-n) = mempty`.
 *  | For that, we would additionally need the ability to invert elements, i.e.
 *  | a Group.
 */
var power = function (dictMonoid) {
    return function (x) {
        var go = function (p) {
            if (p <= 0) {
                return mempty(dictMonoid);
            };
            if (p === 1) {
                return x;
            };
            if (p % 2 === 0) {
                var x$prime = go(p / 2 | 0);
                return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(x$prime)(x$prime);
            };
            if (Data_Boolean.otherwise) {
                var x$prime = go(p / 2 | 0);
                return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(x$prime)(Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(x$prime)(x));
            };
            throw new Error("Failed pattern match at Data.Monoid line 49, column 3 - line 53, column 57: " + [ p.constructor.name ]);
        };
        return go;
    };
};
module.exports = {
    Monoid: Monoid, 
    mempty: mempty, 
    power: power, 
    monoidUnit: monoidUnit, 
    monoidFn: monoidFn, 
    monoidString: monoidString, 
    monoidArray: monoidArray
};
